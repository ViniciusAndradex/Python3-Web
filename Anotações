Seção Básica:
    Comentários:
        # : Deixa o código comentado.
        """/''': São docstrings, porém servem como comentário.
        OBS: Padrão da comunidade, 2 espaços em caso de já existir algum dado
             na linha.

    Print:
        print(): Escreva.
        print('',''): Por padrão a vírgula representa espaço.
        print('','', sep='-'): Por padrão a vírgula representa espaço, o sep indica o tipo do separador.
        print('','', sep='-', end=''): Por padrão a vírgula representa espaço,
                                       o sep indica o tipo do separador, end='' não quebra linha.
        Exercicio da aula: Criar um cpf com parâmetos do print.
        OBS: Em python () ao final de um comando indica uma função em Python.
        OBS: O python é case sensitive.

    Strings:
        str: Tipo primitivo de texto, esse tipo é identificado por aspas.
        Caractere de escape:
            \: Com esse caractere a frente a aspa é ignarada como comando.
            OBS: Não recomendado por que fica estranho, além de que existem outros comandos com \.
        print(r''): Indica que nada devera ser executado.
        OBS: O python é uma linguagem de tipagem dinâmica, ou seja, consegue idenficar os tipos.
        OBS: As aspas podem estar uma dentro da outra desde que sejam diferentes. ("''") ou ('""')

    Tipos Primitivos:
        str - int - float - bool
        str: String
        int: Inteiro
        float: Real
        bool: Lógico
        casting:
            tipo(valor) isso transforma quando possível um valor de tipo x a y.
        Função:
            type(): indica o tipo do dado.
        OBS: Valores vazios quando castados para bool() são tratados como falso.

    Operadores Aritméticos:
        [+ , -, *, /, //, **, %, ()]
        Ordem de preceência:
            -> | () | ** | * | / | // | % | + | - |

    Variáveis:
        Regras: Iniciar com letra, pode conter números, separar por _, letras minúsculas.
        São apelidos dados a nossas regiões de memória.

    Formatação de string:
        f'strings:
            printf(f''{var}) <- melhor maneira de utilizar as strings.

    DESAFIO - Aula 8 dos conteúdos anteriores.
    --------------------------------------------------------------------------------------------------------------------
    Entrada de dados:
        input('texto que apresentará ao user: ') <- utilizado com variáveis.
        nome = tipo(input(''))

    Condições:
        IF, ELIF e ELSE.
        if condição (True já garante o verdadeiro):
            bloco
        elif condição:
            bloco
        else:
            bloco

    Operadores relacionais:
        == | > | >= | < | <= | !=
        Permite a comparação de dados sempre retornando um valor boolean.

    Operadores Lógicos:
        and | or | not | in | not in
        and(e): V | V -> True
        or(ou): F | V -> True
        not: inverte o valor (bool)!
        OBS: O not também é usada para testes com variáveis vazios já que se não tiver nada retorna True.

    len:
        len(): Indica o número de caracteres de uma string.
        Essa função funciona sobre o pano, ou seja, por ser um função para string podemos chamar também
        como string.__len__()

        OBS: Não funciona com números.
        OBS: em python tudo é objeto.

    Documentações e funções built-in:
        funções:
            isdecimal()
            isdigit()
        OBS: Quando houver qualquer dúvida, buscar consultar na documentação da função.

    Placeholder e elipisis:
        pass: Está palavra indica que o programador deixou para escrever o código depois e ao colocar
              esse termo o código continua funcionando sem erros.

        ...: faz a mesma coisa apesar de não ser comum.

    Formatando valores:
        Modificadores:
            :s - texto
            :d - inteiros
            :f - float
            :.(num)f - quantidade de casas decimais, float
            :caractere (<, > e ^)(quantidade)(tipos - s, d ou f)
        Função:
            zfill = preenche com 0 de acordo com tamanho passado.
            l/rjust(tam, 'caractere') = faz a formatação de acordo com tamanho e caractere.
            upper() - lower() - title()
        Fatiamento:
            Todas as strings possuem indices e portanto podemos acessar com os fatiamentos.
            Os indices podem ser positivos e negativos, os negativos fazem a conta de trás para frente da string.
            string[ini:fim:passo]
        Funções:
            len() | abs | type | print...

    Laços de repetição:
        While:
            while condição:
                bloco
        continue: essa palavra reservada pula para o próximo laço impedindo a exibição do bloco e
                  podemos para para certas coisas.
        break: encerra o laço.
        while/else:
            A expressão else pode ser usada após o laço que é quando a expressão do laço passa ser falsa,
            o que pode ser uma boa alternativa para exibições e calculos.
            while condição:
                bloco
            else: # Somente quando o laço se tornar falso.
                bloco

        iterações com strings (WHILE):
            iterar: Significa varrer um determinado objeto que possue indices.
            hardcode = explicitando um dado.

        For in:
            for c in range()/var:  range(start, stop, step)
                bloco

        For Else:
            break | continue
            métodos:
               startswith(''): responde se a primeira letra de uma string corresponde a digitada.

    Listas:
            Variáveis compostas!
            declaração:
                lista = [] ou list()
            métodos:
                trocar valor: lista[5] = 'Meu'
                append(): adc ao final
                insert(): adc na posição
                pop(): exclui o ultimo elemento ou posição indicada.
                del(): exclui o elemento indicado.
                clear(): limpa toda a lista
                extend(): a partir de uma lista já criada você consegue extender outra, ou seja, adicionar ao final.

    String metods:
        Split: Divide strings, de acordo com separador que nós indicamos.
        Join: Junta elementos.
        Enumerate: Enumera elementos iteraveis, é possível também indicar o elemento no qual o enumerate começa.
        --->    Ao utilizar o enumerate nós criamos uma tupla com o valor de enumerate + o valor de minha lista
                é possível também desempacotar, ou seja, o valor que foi devolvido agora possui dois valores e
                portanto basta duas variáveis receberem o valor.
        count: conta um elemento indicado.
        strip: exclui espaços inuteis.

    Desempacotamento de listas e python:
        lista[0, 1, 2]
        n1, n2, n3 = lista <- Da forma que descrevemos cada variável recebe um valor dalista, ou seja,
                              foram desempacotadas
        OBS: Em caso de mais valores do que váriavel utilizamos do *qualquer_nome
            Exemplo:
                n, m, *qualquer_nome = lista <- Qualquer nome gera uma lista com os valores restantes.
                OBS: qualquer_nome recebe qualquer valor que não esteja em outra variável, ou seja, se criarmos uma var
                     após o mesmo o valor é retirado da sua lista e pode ocorrer para qualquer número de var.

    Trocando valor de Variáveis:
        x = 10
        y = 15
        y, x = x, y -> Uma especie de desempacotamento.

    Operador Ternário:
        var = bloco True if condiçãoTrue else bloco False

    Expresões or:
        print(nome or 'Você não digitou nada')

    Funções Parte 1:
        definição:
            def nome(parametros)

        Utilizado para evitar repetição de códigos.
        Parametros:
            def func(msg, ...):
        Valores padrões:
            def func(msg='oi', num=0)

            func(num=5, msg='PICA')
        Funções não são comumente utilizadas para prints.

    Funções parte 2 [RETURN]:
        Funções que retornam algo.
        declaração:
            def func(var=''):
                return var -> Ao encontrar retorno está encerrado a minha função!
                return 'A', 'B' -> Esse tipo de dado retorna uma tupla, listas imutaveis.
        OBS: As funções podem retornar uma a outra sendo que é possível retornar o próprio valor e
             a função em si. Isso implica dizer que um variável que recebe esse valor pode se tornar
             a propria variavel com seus parâmetros e retornos pois estão ligadas em relação ao endereço
             na memória.
        OBS: Se não colocar os parenteses o retorno de uma função é simplesmente ela mesma com um type function.
        OBS: none, significa não valor podemos utilizar como false em if's.

    Funções parte 3:
        *args | **kwargs [keywords arguments] -> Nomes padrões

        Funções com retorno:
            Quando um variavel recebe uma função seus dados passam a receber indices também e
            podem passar a ser chamados por indices.

            def fun(a, b, c)
                return a, b -> Estamos retornando uma tupla com os valores.
            j = fun(2,3,4)
            print(jun[1]) -> retornaria b.
        parametros:
            def func(*args) -> O args funciona como uma lista (tupla), e portanto acessamos os dados como
                               um desempacotamento. é possível castar essa tupla para lista e modificar o
                               dado.
            def func(**kwargs) -> esse argumento armazena valores passados por chaves, ou seja, nome=,
                                  idade=, jonas=... em um dicionário separada.
        metodos:
            kwargs.get(key): atribuisse o valor da chave a uma variável, melhor maneira de trabalhar pois
                             não gera excessão no maximo a var fica com none.

        OBS: Para desempacotar é possível também só utilizar o *lista no print que cada dado será
             exibido por sua vez.
        OBS: Se houver a algum argumento que se tenha um padrão todos após o mesmo tende ser padrão
             funciona da mesma forma com o programa principal.

        Funções parte 4:
            | escopo |
            def dunc():
                global var => Altera em qualquer lugar do código

            OBS: Quando utilizamos uma função para chamar outras, é importante usarmos os args e kwargs
                 pois os mesmos nos permitem passar os argumentos de forma direta sem a necessidade de
                 pedir na função.
            OBS: não é uma boa prática de programação
            OBS: Ao declarar em qualquer lugar da minha função uma suposta var global
                 ela passa a ser a local e portanto se foi feito algo antes disso, dara um erro.
            BP: Evitar utilizar variáveis globais dentro das minhas funções.

    Expressões lambda (funções anônimas):
        Declaração:
            Está expressão é indicada no programa princiapal!
            var = lambda args: retorno

        Exemplo de uso:
            def func(item):
                return item[1]
            Nesse exemplo foi criado uma função para retornar somente o valor da chave da lista que eu  queria
            sendo que não precisamos pois podemos utilizar das expressões lambda para isso.
            lista.sort(key=lambda item: item[1])
            também pode ser: lista, key=lambda i: i[1]

        OBS: Estas funções são utilizadas com a finalidade de simplificar meu código, devemos sempre deixar
             o mais limpo possível. Portanto resoluções simples que necessitam de função usamos lambda.
        OBS: Utilizado para passar parametros para a criação de interfaces gráficas.

    Tuplas:
        declaração:
            t = () or tuple() or 1, 2, 3 and 1,
        Concatenação:
            t = t + t1 por exemplo
        Multiplicação de tuplas:
            t = (1, 2) * 10 -> 10x 1,2
        Conversão para lista:
            list(t1) e agora pode ser modificado!!

    Dicionario:
        Declaração:
            {}, dict()
        Adição de elementos e alteração de valor:
            dict['nome_da_chave'] = valor da chave -> Mais comum]
            dict['nome_da_chave'] = valor da chave_mudei or dict.update({'nova_chave': 'mudei_denovo'})
        Keys:
            regras:
                strings, int or tuple: Isto ocorre pois todos os valores são imutaveis.
        Metodos:
            var.get: Esse método nos retorna none caso a chave passada ao mesmo não exista, assim evitando que o
                     código quebre
            del var['chave']
            len(dict): número de pares key - value
            var.pop(chave)
            var.popitem(): elimina o último.

        Associação:
            dict = {1: 'a', 2: 'b'}
            a = dict -> Desta forma a variavel se liga ao dict e portanto ambos se modificam, ou seja, cada modificação
                        afeta ambas as variáveis.
            a = dict.copy -> shallow copy implica dizer que os valores não se copiam mas o que ocrre é um referenciamento,
             ou seja, elementos que podem ser alterados como listas, se alteram em ambas as listas uma soluçãoé o
             modulo copy. from copu import deepcopy
        casting:
            dict(lista, tuple) -> desde que exista um par nas mesmas
        Concatenação:
            var.update(var1)
        OBS: Uma key não pode ter um mesmo nome de outra, caso isso ocorra o ultimo valor é o que prevalece e sobrescreve
             os outros.

    Conjuntos/sets:
        Coleção de elementos, os sets só suportam elementos unicos, ou seja, só recebem valores.
        Set não possui indice e portanto não tem um acesso direto.
        Declaração:
            set1 = {1,2,3,4,5} ou set()
        metodos:
            set.add(valor)
            s1.discard(valor)
            s1.update(valor) -> Recebe elemento de forma iteravel, ou seja, esse elemento é passado 'picotado'
            union/|: Essa função une os elementos do set. -> s3 = s1 | s2
            intersection/&: O set só recebe valores que estão em ambos os sets
            difference/-: Estão função exibe os valores que não pertence a intersection do variavel a esquerda.
                          exemplo:
                            s = {1, 2, 3, 4, 5, 6}
                            s2 = {1, 4, 9, 4, 10, 11}
                            s5 = s - s2
                            ---> {2, 3, 5, 6}
            symmetric_difference/^: Exibe os valoresque não estão em intersection de ambo os sets.
            OBS: UPDATE normalmente é usado para objetos com mais de um.
            OBS: Os sets não duplicam valores então pode ser uma alternativa se tratando desse tipo de problema.
        OBS: Os sets não respeitam ordem e portanto a cada execução eles podem mudar.